#!/usr/bin/python
import os, sys, itertools, multiprocessing
from subprocess import Popen
from external import optfunc
from os.path import abspath, dirname
from datetime import datetime

def vprint(s, verbose):
    if verbose:
        print
        print s

def call(cmd, verbose=False, allow_fail=False):
    if verbose:
        print cmd
    p = Popen(cmd, shell=True)
    p.communicate()
    status = p.returncode
    if status != 0 and not allow_fail:
        if not allow_fail:
            print "command failed:\n%s" % cmd
            exit()
        else:
            return call(cmd, verbose, allow_fail)
    else:
        return status

def parse_dimension(str):
	key, vals = str.split(":")
	vals = vals.split(",")
	return map(lambda x: {key: x}, vals)

def parse_params(params):
    if params == "":
        return [{None: None}]
    else:
        dimensions = params.split(" ")
        return map(parse_dimension, dimensions)

def compute(pair):
    exec_str, verbose = pair
    pre = datetime.now()
    return_str =  call(exec_str, verbose, True)
    post = datetime.now()
    delta = post-pre
    seconds = delta.seconds + delta.microseconds/1000000.0
    return seconds

compilers = {
    "vicare" : {
        #"header" : "scheme-compilers/header-vicare.sc",
        #"trailer" : "scheme-compilers/trailer-vicare.sc",
        "template" : "scheme-compilers/vicare-template.sc",
        "extension" : ".ss",
        "runnable" : True },
    "biwa" : {
        #"header" : "scheme-compilers/header-biwa.sc",
        #"trailer" : "scheme-compilers/trailer-biwa.sc",
        "template" : "scheme-compilers/biwa-template.sc",
        "extension" : ".html",
        "runnable" : False },
    "scheme2js" : {
        #"header" : "scheme-compilers/header-scheme2js.sc",
        #"trailer" : "scheme-compilers/trailer-scheme2js.sc",
        "template" : "scheme-compilers/scheme2js-template.sc",
        "extension" : ".sc",
        "runnable" : False },
    }

@optfunc.main
@optfunc.arghelp('verbose', 'display all executed commands')
@optfunc.arghelp('debug', 'run all ikarus commands in debug mode')
@optfunc.arghelp('pretty', 'keep & pretty-print compiled file')
@optfunc.arghelp('ext', 'definitions to be included in header of compiled file')
@optfunc.arghelp('time', 'record the time it takes for the compiled file to run')
@optfunc.arghelp('set', 'run church file with multiple parameter settings')
@optfunc.arghelp('keep', 'do not delete compiled file')
@optfunc.arghelp('numcores', 'number of cores to run parallel jobs on')
@optfunc.arghelp('compiler', 'compiler to use (available: vicare, biwa, scheme2js)')
def main(file, verbose=False, debug=False, keep=False, pretty=False, time=False, norun=False, ext="", set="", compiler="vicare",numcores=None):
    """Usage: %prog <file> [options]

Examples:

  bher foo.church -dp
  Compile & run foo.church in debug mode, pretty-print compiled file
  to foo.church.ss.

  bher foo.church -v -e defs.ss
  Compile & run foo.church including definitions from defs.ss, print
  all commands used.

  bher foo.church -t -s samples:10,100,1000
  Compile & run foo.church three times, replacing %(samples)s in
  foo.church with 10, 100, and 1000 respectively. Print out runtime
  for each setting.

  bher foo.church -c biwa
  Compile foo.church to html/js.
"""
    if pretty: keep = True
    params = parse_params(set)
    bher_path = abspath(dirname(sys.argv[0]))
    settings = {
        "bher_path" : bher_path,
        "in_path" : abspath(file),
        "in_dir" : dirname(abspath(file)),
        ##"header_path" : abspath(os.path.join(bher_path, compilers[compiler]["header"])),
        ##"trailer_path" : abspath(os.path.join(bher_path, compilers[compiler]["trailer"])),
        "template_path" : abspath(os.path.join(bher_path, compilers[compiler]["template"])),
        "compiler" : abspath(os.path.join(bher_path, "church/church-compiler.ss")),
        "debug" : debug and "--debug" or "",
        "pretty" : pretty and "T" or "F",
        "ext" : ext and abspath(ext) or "",
        "file": file
    }
    
    compute_space = []

    dimensions = map(lambda x: x.split(":")[0], set.split(" "))

    settings["out_path"] = abspath(file) + ".ss"
    vprint("removing old compilation files (if existent)", verbose)
    call("rm -f '%(out_path)s'" % settings, verbose, allow_fail=True)
    call("rm -f '%(file)s.template'" % settings, verbose, allow_fail=True)
    call("cd %(in_dir)s; ls %(file)s.* | xargs rm -f" % settings, verbose, allow_fail=True)
    
    
    ## replace %(foo)s with __INTERPOLATE__foo
    reInterpolate = {}
    for dim in dimensions:
         reInterpolate[dim] = "__INTERPOLATE__" + dim

    vprint("processing input file", verbose)
    code = open(file).read() % reInterpolate
    f = open(file + ".template", "w")
    f.write(" ".join(map(lambda dim: "(define __INTERPOLATE__" + dim + " 1.2345)", dimensions)))
    f.write("\n\n"+code)
    
    f.close()

    vprint("compiling church->scheme", verbose)
    call(("cd '%(bher_path)s' && vicare %(debug)s --r6rs-script '%(compiler)s' " +
          "'%(file)s.template' '%(out_path)s.template' '%(ext)s' %(pretty)s") % settings, verbose)
          
    # prepare to splice in the compiled code
    settings["churchprogram"] = open('%(out_path)s.template' % settings).read()

    vprint("wrapping with compiler-specific template", verbose)
    template = open(settings["template_path"]).read()
    open(settings["out_path"], "w").write(template % settings)
    
    for (i,dicts) in enumerate(itertools.product(*params)):
        settings["i"] = i
        
        # combine the "unitary" dictionaries
        dimensionvalues = reduce(lambda x,y: dict(x.items() + y.items()), dicts)
        sedCmd = "sed "
        for k,v in dimensionvalues.items():
            sedCmd += " -e 's/(church-__INTERPOLATE__%(k)s 1.2345)//' -e \"s/church-__INTERPOLATE__%(k)s/%(v)s/\"" % {'k': k, 'v': v}
        sedCmd += (" %(file)s.ss > %(file)s.%(i)s.ss") % settings
        call(sedCmd, verbose, allow_fail=True)
        
        compute_space.append(["vicare %(debug)s --r6rs-script '%(file)s.%(i)s.ss'" % settings, verbose])
    
    if __name__ == '__main__':
        if not (numcores == None):
            numcores = int(numcores)
        pool = multiprocessing.Pool(numcores)
        results = []
        r = pool.map_async(compute, compute_space, callback=results.append)
        r.wait() # Wait on the results
        print results
